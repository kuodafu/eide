// 内部方法
#include "EIDE_InternalMethods.h"
#include <unordered_set>
#include "EIDE_Interface.h"

// 出错后需要执行的代码
#define INTERNAL_ERROR(_s) 

namespace auto_free_memory
{
    struct FREE_MEMORY_DATA
    {
        FREE_MEMORY_DATA() :joinTimer(0), ptr(0), pfn(0), freeTimer(0) { }
        FREE_MEMORY_DATA(void* p, pfn_EIDE_FreeMemory pfn, DWORD freeTimer) :
            joinTimer(0), ptr(p), pfn(pfn), freeTimer(freeTimer)
        {
            joinTimer = GetTickCount64();
        }
        void* ptr;                      // 释放的内存
        pfn_EIDE_FreeMemory pfn;        // 需要释放内存时调用的函数
        ULONGLONG joinTimer;            // 加入释放队列时的时间
        DWORD freeTimer;                // 释放时长, 需要这么个时长后调用 pfn
    };
    typedef FREE_MEMORY_DATA* LPFREE_MEMORY_DATA;
    static std::unordered_set<LPFREE_MEMORY_DATA> s_free_memory;
    static LPCRITICAL_SECTION s_free_xkq;
    static bool s_IsLoopFree;
    inline static void __get_xkz()
    {
        if (!s_free_xkq)
        {
            s_free_xkq = new CRITICAL_SECTION;
            InitializeCriticalSection(s_free_xkq);
        }
    }

    static DWORD CALLBACK ThreadProc_free_pstr(LPVOID lpParam)
    {
        while (s_IsLoopFree)
        {
            Sleep(1000);    // 线程内, 调用这个延时就可以
            EnterCriticalSection(s_free_xkq);   // 进入许可区

            // 全部枚举一遍看哪个够时间释放,
            for (auto it = s_free_memory.begin(); it != s_free_memory.end(); ++it)
            {
                const LPFREE_MEMORY_DATA& data = *it;
                if (GetTickCount64() - data->joinTimer >= data->freeTimer)
                {
                    data->pfn(data->ptr);
                    delete data;
                    s_free_memory.erase(it++);
                }
            }
            LeaveCriticalSection(s_free_xkq);   // 退出许可区
        }
        DeleteCriticalSection(s_free_xkq);
        delete s_free_xkq;
        return 0;
    }



    void push_free_memory(void* ptr, pfn_EIDE_FreeMemory pfn, DWORD freeTimer)
    {
        if (!s_IsLoopFree)
        {
            s_IsLoopFree = true;
            __get_xkz();
            HANDLE hThread = CreateThread(0, 0, ThreadProc_free_pstr, 0, 0, 0);
            if (hThread)CloseHandle(hThread);
        }
        EnterCriticalSection(s_free_xkq);   // 进入许可区
        FREE_MEMORY_DATA* data = new FREE_MEMORY_DATA(ptr, pfn, freeTimer);
        s_free_memory.insert(data);
        LeaveCriticalSection(s_free_xkq);   // 退出许可区
    }
}

// 把一个内存加入到自动释放列表里, 到时间后会调用释放回调函数, 此函数线程安全
// ptr = 需要自动释放的内存
// pfn = 释放内存时调用的地址, 会把被释放的内存传递过去
// freeTimer = 多久释放, 到这个时间后就调用 pfn来进行释放内存
void* EIDE_PushMemory(void* ptr, pfn_EIDE_FreeMemory pfn, DWORD freeTimer)
{
    auto_free_memory::push_free_memory(ptr, pfn, freeTimer);
    return ptr;
}



// 从代码窗口句柄获取CWnd类, 成功返回类指针
LPBYTE CWnd_FromHandle(HWND hWnd)
{
    typedef LPBYTE(WINAPI* pfn_call)(HWND);
    static pfn_call mCWnd_FromHandle = 0;
    if (!mCWnd_FromHandle)
    {
        const BYTE find[] = { 0, 86, 87, 106, 1, 232 };
        LPBYTE address = EIDE_FindAddress(find, sizeof(find));
        if (!address)
        {
            INTERNAL_ERROR("FromHandle 初始化失败");
            return 0;
        }
        mCWnd_FromHandle = (pfn_call)(address + 1);
    }
    if (mCWnd_FromHandle)
        return mCWnd_FromHandle(hWnd);
    return 0;
}

int __stdcall SizeOfCode(LPBYTE m)
{
    typedef int(WINAPI* pfn_sizeofCode)(LPBYTE m);
    static pfn_sizeofCode ptr = 0;
    if (!ptr)
    {
        const BYTE code[] =
        {
            0x83, 0xEC, 0x28, 0x89, 0xE0, 0x50, 0xFF, 0x75, 0x08, 0x31, 0xC0, 0xE8, 0x04, 0x00, 0x00, 0x00, 0xC9, 0xC2, 0x04, 0x00,
            0x55, 0x89, 0xE5, 0xC9, 0x60, 0x8B, 0x7C, 0x24, 0x28, 0x31, 0xC0, 0x31, 0xC9, 0x31, 0xDB, 0x99, 0xB1, 0x25, 0xF3, 0xAA,
            0x83, 0xEF, 0x25, 0x8B, 0x74, 0x24, 0x24, 0xAC, 0x3C, 0xF3, 0x74, 0x04, 0x3C, 0xF2, 0x75, 0x05, 0x88, 0x47, 0x01, 0xEB,
            0xF2, 0x3C, 0xF0, 0x75, 0x05, 0x88, 0x47, 0x02, 0xEB, 0xE9, 0x3C, 0x2E, 0x74, 0x14, 0x3C, 0x36, 0x74, 0x10, 0x3C, 0x3E,
            0x74, 0x0C, 0x3C, 0x26, 0x74, 0x08, 0x3C, 0x64, 0x74, 0x04, 0x3C, 0x65, 0x75, 0x05, 0x88, 0x47, 0x03, 0xEB, 0xCC, 0x3C,
            0x66, 0x75, 0x07, 0x88, 0x47, 0x04, 0xB2, 0x01, 0xEB, 0xC1, 0x3C, 0x67, 0x75, 0x07, 0x88, 0x47, 0x05, 0xB3, 0x01, 0xEB,
            0xB6, 0x88, 0x47, 0x06, 0x88, 0xC7, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x59, 0x81, 0xC1, 0x59, 0x01, 0x00, 0x00, 0x3C, 0x0F,
            0x75, 0x09, 0xAC, 0x88, 0x47, 0x07, 0x83, 0xC1, 0x40, 0xEB, 0x0A, 0x3C, 0xA0, 0x72, 0x06, 0x3C, 0xA3, 0x77, 0x02, 0x88,
            0xDA, 0x88, 0xC6, 0x80, 0xE6, 0x03, 0xC0, 0xE8, 0x02, 0x8A, 0x04, 0x01, 0x00, 0xF0, 0x8A, 0x0C, 0x01, 0xF6, 0xC1, 0x01,
            0x0F, 0x84, 0xB9, 0x00, 0x00, 0x00, 0xAC, 0x88, 0x47, 0x08, 0x88, 0xC5, 0xC0, 0xED, 0x06, 0x88, 0x6F, 0x09, 0x88, 0xC6,
            0x80, 0xE6, 0x07, 0x88, 0x77, 0x0B, 0xC0, 0xE0, 0x02, 0xC0, 0xE8, 0x05, 0x88, 0x47, 0x0A, 0x3C, 0x01, 0xAC, 0x77, 0x10,
            0x80, 0xFF, 0xF6, 0x75, 0x03, 0x80, 0xC9, 0x02, 0x80, 0xFF, 0xF7, 0x75, 0x03, 0x80, 0xC9, 0x10, 0x30, 0xFF, 0x08, 0xED,
            0x75, 0x14, 0x08, 0xDB, 0x74, 0x09, 0x80, 0xFE, 0x06, 0x75, 0x0B, 0xB7, 0x02, 0xEB, 0x07, 0x80, 0xFE, 0x05, 0x75, 0x02,
            0xB7, 0x04, 0x80, 0xFD, 0x01, 0x75, 0x02, 0xB7, 0x01, 0x80, 0xFD, 0x02, 0x75, 0x0A, 0x08, 0xDB, 0x74, 0x04, 0xB7, 0x02,
            0xEB, 0x02, 0xB7, 0x04, 0x80, 0xFD, 0x03, 0x74, 0x34, 0x80, 0xFE, 0x04, 0x75, 0x2F, 0x08, 0xDB, 0x75, 0x2B, 0x46, 0x88,
            0x47, 0x0C, 0x88, 0xC4, 0xC0, 0xEC, 0x06, 0x88, 0x67, 0x0D, 0x88, 0xC4, 0xC0, 0xE4, 0x02, 0xC0, 0xEC, 0x05, 0x88, 0x67,
            0x0E, 0x24, 0x07, 0x88, 0x47, 0x0F, 0x3C, 0x05, 0x75, 0x0B, 0x08, 0xED, 0x74, 0x05, 0x80, 0xFD, 0x02, 0x75, 0x02, 0xB7,
            0x04, 0x4E, 0x80, 0xFF, 0x01, 0x75, 0x04, 0xAC, 0x88, 0x47, 0x17, 0x80, 0xFF, 0x02, 0x75, 0x06, 0x66, 0xAD, 0x66, 0x89,
            0x47, 0x18, 0x80, 0xFF, 0x04, 0x75, 0x04, 0xAD, 0x89, 0x47, 0x1A, 0xF6, 0xC1, 0x10, 0x74, 0x27, 0xF6, 0xC1, 0x40, 0x74,
            0x12, 0x08, 0xD2, 0x74, 0x08, 0x66, 0xAD, 0x66, 0x89, 0x47, 0x1F, 0xEB, 0x45, 0xAD, 0x89, 0x47, 0x21, 0xEB, 0x3F, 0x08,
            0xD2, 0x74, 0x08, 0x66, 0xAD, 0x66, 0x89, 0x47, 0x11, 0xEB, 0x04, 0xAD, 0x89, 0x47, 0x13, 0xF6, 0xC1, 0x08, 0x74, 0x04,
            0xAD, 0x89, 0x47, 0x13, 0xF6, 0xC1, 0x04, 0x74, 0x06, 0x66, 0xAD, 0x66, 0x89, 0x47, 0x11, 0xF6, 0xC1, 0x02, 0x74, 0x04,
            0xAC, 0x88, 0x47, 0x10, 0xF6, 0xC1, 0x40, 0x74, 0x04, 0xAD, 0x89, 0x47, 0x21, 0xF6, 0xC1, 0x20, 0x74, 0x04, 0xAC, 0x88,
            0x47, 0x1E, 0x96, 0x2B, 0x44, 0x24, 0x24, 0xAA, 0x89, 0x44, 0x24, 0x1C, 0x61, 0xC2, 0x08, 0x00, 0x89, 0x83, 0x89, 0x83,
            0x89, 0x83, 0x89, 0x83, 0x89, 0x83, 0x89, 0x83, 0x89, 0x83, 0x89, 0x83, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
            0x87, 0x85, 0x93, 0x85, 0x9A, 0x9A, 0x9A, 0x9A, 0xA0, 0x89, 0x89, 0x89, 0x85, 0x85, 0xA7, 0x85, 0x90, 0x85, 0x83, 0x85,
            0x80, 0x80, 0x90, 0x90, 0xAB, 0x9E, 0xAF, 0xCA, 0x89, 0xC7, 0x89, 0x89, 0x9A, 0x80, 0x97, 0x85, 0x85, 0x87, 0x85, 0x87,
            0x49, 0x45, 0x45, 0x79, 0x49, 0x49, 0x4C, 0x45, 0x49, 0x78, 0x49, 0x49, 0x45, 0x45, 0x45, 0x45, 0x49, 0x49, 0x49, 0x49,
            0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x62, 0x4A, 0x45, 0x49, 0x7D, 0x7D, 0x7D, 0x7D, 0x49, 0x49, 0x49, 0x49,
            0x46, 0x74, 0x46, 0x81, 0x49, 0x49, 0x8C, 0x49, 0x83, 0x63, 0x45, 0x45, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,
            0x49, 0x49, 0x49, 0x4A, 0x02, 0x02, 0x02, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
            0x10, 0x10, 0x10, 0x10, 0x11, 0x02, 0x03, 0x50, 0x50, 0x14, 0x20, 0x20, 0x20, 0x20, 0x01, 0x01, 0x03, 0x11, 0x03, 0x03,
            0x03, 0x03, 0x01, 0x00, 0x00, 0x14, 0x00, 0x03, 0x03, 0x04, 0x00, 0x06, 0x00, 0x04, 0x00, 0x02, 0x03, 0x01, 0x00, 0x00,
            0x01, 0x00, 0x01, 0x00, 0x03, 0x50, 0x50, 0x50, 0x50, 0x03, 0x01, 0x01, 0x01, 0x03, 0x01, 0x02, 0x02, 0x00, 0x00, 0x02,
            0x00, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        };
        ptr = (pfn_sizeofCode)VirtualAlloc(0, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if (ptr)
        {
            memcpy(ptr, code, sizeof(code));
        }
    }
    if (ptr)
        return ptr(m);
    return 0;
    //VirtualFree(ptr, 0, MEM_RELEASE);
}



int 取子程序真实地址(const void* pFun)
{
    if (!pFun) return 0;
    LPBYTE m = (LPBYTE)pFun;
    LPBYTE r = 0;
    int i = 0;
    BYTE code = 0;
    int len = 0;
    do
    {
        code = *m;
        if (code == OP_RET || code == OP_RETN)
            break;
        if (code == OP_CALL)
        {
            r = m + 1;
            i++;
            if (i == 2)break;
        }
        len = SizeOfCode(m);
        if (len == 0)break;
        m += len;
    } while (m);
    if (r)
    {
        r = (*((int*)r)) + r + 4;
        if (r[0] == 255 && r[1] == 37)
            r = (LPBYTE)(*((int*)(r + 2)));
    }
    return (int)r;
}